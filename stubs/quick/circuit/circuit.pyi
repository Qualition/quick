# Copyright 2023-2025 Qualition Computing LLC.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://github.com/Qualition/quick/blob/main/LICENSE
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import abc
import cirq
from collections.abc import Sequence
from contextlib import contextmanager
import matplotlib.pyplot as plt
import numpy as np
import pennylane as qml # type: ignore
import pytket
import qiskit # type: ignore
from abc import ABC, abstractmethod
from numpy.typing import NDArray
from quick.backend import Backend
from quick.circuit.dag import DAGCircuit
from quick.primitives import Bra, Ket, Operator
from quick.synthesis.unitarypreparation import UnitaryPreparation
from types import NotImplementedType
from typing import Any, Callable, Literal, Type

__all__ = ["Circuit"]

GATES = Literal[
    "I", "X", "Y", "Z", "H", "S", "Sdg", "T", "Tdg", "RX", "RY", "RZ", "Phase", "U3"
]


class Circuit(ABC, metaclass=abc.ABCMeta):
    num_qubits: int
    circuit: Any
    gate_mapping: dict[str, Callable]
    measured_qubits: set[int]
    circuit_log: list[dict]
    stack: list[list[dict]]
    global_phase: float
    process_gate_params_flag: bool
    def __init__(self, num_qubits: int) -> None: ...
    def convert_param_type(self, value: Any) -> int | float | list: ...
    def _process_single_qubit_index(self, qubit_index: Any) -> int: ...
    def validate_qubit_index(self, name: str, value: Any) -> int | list[int]: ...
    def _validate_single_angle(self, angle: Any) -> float: ...
    def validate_angle(self, name: str, value: Any) -> None | float | list[float]: ...
    def process_gate_params(self, gate: str, params: dict) -> dict | None: ...
    @contextmanager
    def decompose_last(self, gate: dict | None): ...
    @abstractmethod
    def _define_gate_mapping(self) -> dict[str, Callable]: ...
    @abstractmethod
    def _gate_mapping(
            self,
            gate: GATES,
            target_indices: int | Sequence[int],
            control_indices: int | Sequence[int] = [],
            angles: Sequence[float] = (0, 0, 0)
        ) -> None: ...
    def Identity(self, qubit_indices: int | Sequence[int]) -> None: ...
    def X(self, qubit_indices: int | Sequence[int]) -> None: ...
    def Y(self, qubit_indices: int | Sequence[int]) -> None: ...
    def Z(self, qubit_indices: int | Sequence[int]) -> None: ...
    def H(self, qubit_indices: int | Sequence[int]) -> None: ...
    def S(self, qubit_indices: int | Sequence[int]) -> None: ...
    def Sdg(self, qubit_indices: int | Sequence[int]) -> None: ...
    def T(self, qubit_indices: int | Sequence[int]) -> None: ...
    def Tdg(self, qubit_indices: int | Sequence[int]) -> None: ...
    def RX(self, angle: float, qubit_indices: int | Sequence[int]) -> None: ...
    def RY(self, angle: float, qubit_indices: int | Sequence[int]) -> None: ...
    def RZ(self, angle: float, qubit_indices: int | Sequence[int]) -> None: ...
    def Phase(self, angle: float, qubit_indices: int | Sequence[int]) -> None: ...
    def XPow(self, power: float, global_shift: float, qubit_indices: int | Sequence[int]) -> None: ...
    def YPow(self, power: float, global_shift: float, qubit_indices: int | Sequence[int]) -> None: ...
    def ZPow(self, power: float, global_shift: float, qubit_indices: int | Sequence[int]) -> None: ...
    def RXX(self, angle: float, first_qubit_index: int, second_qubit_index: int) -> None: ...
    def RYY(self, angle: float, first_qubit_index: int, second_qubit_index: int) -> None: ...
    def RZZ(self, angle: float, first_qubit_index: int, second_qubit_index: int) -> None: ...
    def U3(self, angles: Sequence[float], qubit_indices: int | Sequence[int]) -> None: ...
    def SWAP(self, first_qubit_index: int, second_qubit_index: int) -> None: ...
    def CX(self, control_index: int, target_index: int, control_state: str | None = None) -> None: ...
    def CY(self, control_index: int, target_index: int, control_state: str | None = None) -> None: ...
    def CZ(self, control_index: int, target_index: int, control_state: str | None = None) -> None: ...
    def CH(self, control_index: int, target_index: int, control_state: str | None = None) -> None: ...
    def CS(self, control_index: int, target_index: int, control_state: str | None = None) -> None: ...
    def CSdg(self, control_index: int, target_index: int, control_state: str | None = None) -> None: ...
    def CT(self, control_index: int, target_index: int, control_state: str | None = None) -> None: ...
    def CTdg(self, control_index: int, target_index: int, control_state: str | None = None) -> None: ...
    def CRX(self, angle: float, control_index: int, target_index: int, control_state: str | None = None) -> None: ...
    def CRY(self, angle: float, control_index: int, target_index: int, control_state: str | None = None) -> None: ...
    def CRZ(self, angle: float, control_index: int, target_index: int, control_state: str | None = None) -> None: ...
    def CPhase(self, angle: float, control_index: int, target_index: int, control_state: str | None = None) -> None: ...
    def CXPow(
            self,
            power: float,
            global_shift: float,
            control_index: int,
            target_index: int,
            control_state: str | None = None
        ) -> None: ...
    def CYPow(
            self,
            power: float,
            global_shift: float,
            control_index: int,
            target_index: int,
            control_state: str | None = None
        ) -> None: ...
    def CZPow(
            self,
            power: float,
            global_shift: float,
            control_index: int,
            target_index: int,
            control_state: str | None = None
        ) -> None: ...
    def CRXX(
            self,
            angle: float,
            control_index: int,
            first_target_index: int,
            second_target_index: int,
            control_state: str | None = None
        ) -> None: ...
    def CRYY(
            self,
            angle: float,
            control_index: int,
            first_target_index: int,
            second_target_index: int,
            control_state: str | None = None
        ) -> None: ...
    def CRZZ(
            self,
            angle: float,
            control_index: int,
            first_target_index: int,
            second_target_index: int,
            control_state: str | None = None
        ) -> None: ...
    def CU3(
            self,
            angles: Sequence[float],
            control_index: int,
            target_index: int,
            control_state: str | None = None
        ) -> None: ...
    def CSWAP(
            self,
            control_index: int,
            first_target_index: int,
            second_target_index: int,
            control_state: str | None = None
        ) -> None: ...
    def MCX(self, control_indices: int | Sequence[int], target_indices: int | Sequence[int], control_state: str | None = None) -> None: ...
    def MCY(self, control_indices: int | Sequence[int], target_indices: int | Sequence[int], control_state: str | None = None) -> None: ...
    def MCZ(self, control_indices: int | Sequence[int], target_indices: int | Sequence[int], control_state: str | None = None) -> None: ...
    def MCH(self, control_indices: int | Sequence[int], target_indices: int | Sequence[int], control_state: str | None = None) -> None: ...
    def MCS(self, control_indices: int | Sequence[int], target_indices: int | Sequence[int], control_state: str | None = None) -> None: ...
    def MCSdg(self, control_indices: int | Sequence[int], target_indices: int | Sequence[int], control_state: str | None = None) -> None: ...
    def MCT(self, control_indices: int | Sequence[int], target_indices: int | Sequence[int], control_state: str | None = None) -> None: ...
    def MCTdg(self, control_indices: int | Sequence[int], target_indices: int | Sequence[int], control_state: str | None = None) -> None: ...
    def MCRX(self, angle: float, control_indices: int | Sequence[int], target_indices: int | Sequence[int], control_state: str | None = None) -> None: ...
    def MCRY(self, angle: float, control_indices: int | Sequence[int], target_indices: int | Sequence[int], control_state: str | None = None) -> None: ...
    def MCRZ(self, angle: float, control_indices: int | Sequence[int], target_indices: int | Sequence[int], control_state: str | None = None) -> None: ...
    def MCPhase(self, angle: float, control_indices: int | Sequence[int], target_indices: int | Sequence[int], control_state: str | None = None) -> None: ...
    def MCXPow(
            self,
            power: float,
            global_shift: float,
            control_indices: int | Sequence[int],
            target_indices: int | Sequence[int],
            control_state: str | None = None
        ) -> None: ...
    def MCYPow(
            self,
            power: float,
            global_shift: float,
            control_indices: int | Sequence[int],
            target_indices: int | Sequence[int],
            control_state: str | None = None
        ) -> None: ...
    def MCZPow(
            self,
            power: float,
            global_shift: float,
            control_indices: int | Sequence[int],
            target_indices: int | Sequence[int],
            control_state: str | None = None
        ) -> None: ...
    def MCRXX(
            self,
            angle: float,
            control_indices: int | Sequence[int],
            first_target_index: int,
            second_target_index: int,
            control_state: str | None = None
        ) -> None: ...
    def MCRYY(
            self,
            angle: float,
            control_indices: int | Sequence[int],
            first_target_index: int,
            second_target_index: int,
            control_state: str | None = None
        ) -> None: ...
    def MCRZZ(
            self,
            angle: float,
            control_indices: int | Sequence[int],
            first_target_index: int,
            second_target_index: int,
            control_state: str | None = None
        ) -> None: ...
    def MCU3(
            self,
            angles: Sequence[float],
            control_indices: int | Sequence[int],
            target_indices: int | Sequence[int],
            control_state: str | None = None
        ) -> None: ...
    def MCSWAP(
            self,
            control_indices: int | Sequence[int],
            first_target_index: int,
            second_target_index: int,
            control_state: str | None = None
        ) -> None: ...
    def PauliMultiplexor(
            self,
            angles: Sequence[float],
            rotation_axis: Literal["X", "Y", "Z"],
            control_indices: int | Sequence[int],
            target_index: int
        ) -> None: ...
    def UCRX(
            self,
            angles: Sequence[float],
            control_indices: int | Sequence[int],
            target_index: int,
            control_state: str | None = None
        ) -> None: ...
    def UCRY(
            self,
            angles: Sequence[float],
            control_indices: int | Sequence[int],
            target_index: int,
            control_state: str | None = None
        ) -> None: ...
    def UCRZ(
            self,
            angles: Sequence[float],
            control_indices: int | Sequence[int],
            target_index: int,
            control_state: str | None = None
        ) -> None: ...
    def _Diagonal(self, diagnoal: NDArray[np.complex128], qubit_indices: int | Sequence[int]) -> None: ...
    def Diagonal(self, diagnoal: NDArray[np.complex128], qubit_indices: int | Sequence[int]) -> None: ...
    def Multiplexor(
            self,
            single_qubit_gates: list[NDArray[np.complex128]],
            control_indices: int | Sequence[int],
            target_index: int,
            up_to_diagonal: bool=False,
            multiplexor_simplification: bool=True
        ) -> None: ...
    @abstractmethod
    def GlobalPhase(self, angle: float) -> None: ...
    def merge_global_phases(self) -> None: ...
    def QFT(
            self,
            qubit_indices: int | Sequence[int],
            do_swaps: bool=True,
            approximation_degree: int=0,
            inverse: bool=False
        ) -> None: ...
    def initialize(self, state: NDArray[np.complex128] | Bra | Ket, qubit_indices: int | Sequence[int]) -> None: ...
    def unitary(self, unitary_matrix: NDArray[np.complex128] | Operator, qubit_indices: int | Sequence[int]) -> None: ...
    def vertical_reverse(self) -> None: ...
    @staticmethod
    def _horizontal_reverse(circuit_log: list[dict[str, Any]], adjoint: bool=True) -> list[dict[str, Any]]: ...
    def horizontal_reverse(self, adjoint: bool=True) -> None: ...
    def add(self, circuit: Circuit, qubit_indices: int | Sequence[int]) -> None: ...
    @abstractmethod
    def measure(self, qubit_indices: int | Sequence[int]) -> None: ...
    def measure_all(self) -> None: ...
    @abstractmethod
    def get_statevector(self, backend: Backend | None = None) -> NDArray[np.complex128]: ...
    @abstractmethod
    def get_counts(self, num_shots: int, backend: Backend | None = None) -> dict[str, int]: ...
    def get_depth(self) -> int: ...
    def get_width(self) -> int: ...
    @abstractmethod
    def get_unitary(self) -> NDArray[np.complex128]: ...
    def get_instructions(self, include_measurements: bool=True) -> list[dict]: ...
    def get_dag(self) -> DAGCircuit: ...
    def get_global_phase(self) -> float: ...
    def count_ops(self) -> dict[str, int]: ...
    @abstractmethod
    def reset_qubit(self, qubit_indices: int | Sequence[int]) -> None: ...
    def remove_measurements(self) -> Circuit: ...
    def decompose(self, reps: int=1, full: bool=False) -> Circuit: ...
    def transpile(self, direct_transpile: bool=True, synthesis_method: UnitaryPreparation | None = None) -> None: ...
    def compress(self, compression_percentage: float) -> None: ...
    def change_mapping(self, qubit_indices: Sequence[int]) -> None: ...
    def convert(self, circuit_framework: Type[Circuit]) -> Circuit: ...
    def control(self, num_controls: int) -> Circuit: ...
    def update(self) -> None: ...
    @abstractmethod
    def to_qasm(self) -> str: ...
    @staticmethod
    def from_cirq(cirq_circuit: cirq.Circuit, output_framework: Type[Circuit]) -> Circuit: ...
    @staticmethod
    def from_pennylane(pennylane_circuit: qml.QNode, output_framework: Type[Circuit]) -> Circuit: ...
    @staticmethod
    def from_qiskit(qiskit_circuit: qiskit.QuantumCircuit, output_framework: Type[Circuit]) -> Circuit: ...
    @staticmethod
    def from_tket(tket_circuit: pytket.Circuit, output_framework: Type[Circuit]) -> Circuit: ...
    @staticmethod
    def from_qasm(qasm: str, output_framework: Type[Circuit]) -> Circuit: ...
    def copy(self) -> Circuit: ...
    def reset(self) -> None: ...
    @abstractmethod
    def draw(self): ...
    def plot_histogram(self, non_zeros_only: bool=False) -> plt.Figure: ...
    def __getitem__(self, index: int | slice) -> Circuit: ...
    def __setitem__(self, index: int | slice, gates: dict | list[dict] | Circuit) -> None: ...
    def __eq__(self, other_circuit: object) -> bool: ...
    def __len__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def generate_calls(self) -> str: ...
    @classmethod
    def __subclasscheck__(cls, C) -> bool: ...
    @classmethod
    def __subclasshook__(cls, C) -> bool | NotImplementedType: ...
    @classmethod
    def __instancecheck__(cls, C) -> bool: ...

# Copyright 2023-2025 Qualition Computing LLC.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://github.com/Qualition/quick/blob/main/LICENSE
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import numpy as np
import quick.primitives.ket as ket
import quick.primitives.operator as operator
from numpy.typing import NDArray
from typing import overload, SupportsFloat, TypeAlias

__all__ = ["Bra"]

Scalar: TypeAlias = SupportsFloat | complex

class Bra:
    label: str
    norm_scale: np.float64
    data: NDArray[np.complex128]
    shape: tuple[int, int]
    num_qubits: int
    def __init__(self, data: NDArray[np.complex128], label: str | None = None) -> None: ...
    @staticmethod
    def check_normalization(data: NDArray[np.number]) -> bool: ...
    normalized: bool
    def is_normalized(self) -> None: ...
    @staticmethod
    def normalize_data(data: NDArray[np.number], norm_scale: np.float64) -> NDArray[np.number]: ...
    def normalize(self) -> None: ...
    @staticmethod
    def check_padding(data: NDArray[np.number]) -> bool: ...
    padded: bool
    def is_padded(self) -> None: ...
    @staticmethod
    def pad_data(data: NDArray[np.number], target_size: int) -> tuple[NDArray[np.number], tuple[int, ...]]: ...
    def pad(self) -> None: ...
    def to_quantumstate(self) -> None: ...
    def to_bra(self, data: NDArray[np.number]) -> None: ...
    def to_ket(self) -> ket.Ket: ...
    def compress(self, compression_percentage: float) -> None: ...
    def __add__(self, other: Bra) -> Bra: ...
    @overload
    def __mul__(self, other: Scalar) -> Bra: ...
    @overload
    def __mul__(self, other: ket.Ket) -> Scalar: ...
    @overload
    def __mul__(self, other: operator.Operator) -> Bra: ...
    def __rmul__(self, other: Scalar) -> Bra: ...

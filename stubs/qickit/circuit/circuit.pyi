# Copyright 2023-2024 Qualition Computing LLC.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://github.com/Qualition/QICKIT/blob/main/LICENSE
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import abc
import cirq
from collections.abc import Sequence
from contextlib import contextmanager
import matplotlib.pyplot as plt
import numpy as np
import pennylane as qml # type: ignore
import pytket
import qiskit # type: ignore
from abc import ABC, abstractmethod
from numpy.typing import NDArray
from qickit.backend import Backend
from qickit.circuit.dag import DAGCircuit
from qickit.primitives import Bra, Ket, Operator
from qickit.synthesis.unitarypreparation import UnitaryPreparation
import quimb.tensor as qtn # type: ignore
from types import NotImplementedType
from typing import Any, Callable, Literal, Type

__all__ = ["Circuit"]

GATES = Literal[
    "I", "X", "Y", "Z", "H", "S", "Sdg", "T", "Tdg", "RX", "RY", "RZ", "Phase", "U3"
]

class Circuit(ABC, metaclass=abc.ABCMeta):
    num_qubits: int
    circuit: Any
    gate_mapping: dict[str, Callable]
    measured_qubits: set[int]
    circuit_log: list[dict]
    stack: list[list[dict]]
    global_phase: float
    process_gate_params_flag: bool
    def __init__(self, num_qubits: int) -> None: ...
    def convert_param_type(self, value: Any) -> int | float | list: ...
    def validate_qubit_index(self, name: str, value: Any) -> int | list[int]: ...
    def validate_angle(self, name: str, value: Any) -> None | float | list[float]: ...
    def process_gate_params(self, gate: str, params: dict) -> dict | None: ...
    @contextmanager
    def decompose_last(self, gate: dict | None): ...
    @abstractmethod
    def _define_gate_mapping(self) -> dict[str, Callable]: ...
    @abstractmethod
    def _gate_mapping(
            self,
            gate: GATES,
            target_indices: int | Sequence[int],
            control_indices: int | Sequence[int] = [],
            angles: Sequence[float] = [0, 0, 0]
        ) -> None: ...
    def Identity(self, qubit_indices: int | Sequence[int]) -> None: ...
    def X(self, qubit_indices: int | Sequence[int]) -> None: ...
    def Y(self, qubit_indices: int | Sequence[int]) -> None: ...
    def Z(self, qubit_indices: int | Sequence[int]) -> None: ...
    def H(self, qubit_indices: int | Sequence[int]) -> None: ...
    def S(self, qubit_indices: int | Sequence[int]) -> None: ...
    def Sdg(self, qubit_indices: int | Sequence[int]) -> None: ...
    def T(self, qubit_indices: int | Sequence[int]) -> None: ...
    def Tdg(self, qubit_indices: int | Sequence[int]) -> None: ...
    def RX(self, angle: float, qubit_indices: int | Sequence[int]) -> None: ...
    def RY(self, angle: float, qubit_indices: int | Sequence[int]) -> None: ...
    def RZ(self, angle: float, qubit_indices: int | Sequence[int]) -> None: ...
    def Phase(self, angle: float, qubit_indices: int | Sequence[int]) -> None: ...
    def XPow(self, power: float, global_shift: float, qubit_indices: int | Sequence[int]) -> None: ...
    def YPow(self, power: float, global_shift: float, qubit_indices: int | Sequence[int]) -> None: ...
    def ZPow(self, power: float, global_shift: float, qubit_indices: int | Sequence[int]) -> None: ...
    def RXX(self, angle: float, first_qubit_index: int, second_qubit_index: int) -> None: ...
    def RYY(self, angle: float, first_qubit_index: int, second_qubit_index: int) -> None: ...
    def RZZ(self, angle: float, first_qubit_index: int, second_qubit_index: int) -> None: ...
    @abstractmethod
    def U3(self, angles: Sequence[float], qubit_indices: int | Sequence[int]) -> None: ...
    @abstractmethod
    def SWAP(self, first_qubit_index: int, second_qubit_index: int) -> None: ...
    def CX(self, control_index: int, target_index: int) -> None: ...
    def CY(self, control_index: int, target_index: int) -> None: ...
    def CZ(self, control_index: int, target_index: int) -> None: ...
    def CH(self, control_index: int, target_index: int) -> None: ...
    def CS(self, control_index: int, target_index: int) -> None: ...
    def CSdg(self, control_index: int, target_index: int) -> None: ...
    def CT(self, control_index: int, target_index: int) -> None: ...
    def CTdg(self, control_index: int, target_index: int) -> None: ...
    def CRX(self, angle: float, control_index: int, target_index: int) -> None: ...
    def CRY(self, angle: float, control_index: int, target_index: int) -> None: ...
    def CRZ(self, angle: float, control_index: int, target_index: int) -> None: ...
    def CPhase(self, angle: float, control_index: int, target_index: int) -> None: ...
    def CXPow(self, power: float, global_shift: float, control_index: int, target_index: int) -> None: ...
    def CYPow(self, power: float, global_shift: float, control_index: int, target_index: int) -> None: ...
    def CZPow(self, power: float, global_shift: float, control_index: int, target_index: int) -> None: ...
    def CRXX(self, angle: float, control_index: int, first_target_index: int, second_target_index: int) -> None: ...
    def CRYY(self, angle: float, control_index: int, first_target_index: int, second_target_index: int) -> None: ...
    def CRZZ(self, angle: float, control_index: int, first_target_index: int, second_target_index: int) -> None: ...
    def CU3(self, angles: Sequence[float], control_index: int, target_index: int) -> None: ...
    def CSWAP(self, control_index: int, first_target_index: int, second_target_index: int) -> None: ...
    def MCX(self, control_indices: int | Sequence[int], target_indices: int | Sequence[int]) -> None: ...
    def MCY(self, control_indices: int | Sequence[int], target_indices: int | Sequence[int]) -> None: ...
    def MCZ(self, control_indices: int | Sequence[int], target_indices: int | Sequence[int]) -> None: ...
    def MCH(self, control_indices: int | Sequence[int], target_indices: int | Sequence[int]) -> None: ...
    def MCS(self, control_indices: int | Sequence[int], target_indices: int | Sequence[int]) -> None: ...
    def MCSdg(self, control_indices: int | Sequence[int], target_indices: int | Sequence[int]) -> None: ...
    def MCT(self, control_indices: int | Sequence[int], target_indices: int | Sequence[int]) -> None: ...
    def MCTdg(self, control_indices: int | Sequence[int], target_indices: int | Sequence[int]) -> None: ...
    def MCRX(self, angle: float, control_indices: int | Sequence[int], target_indices: int | Sequence[int]) -> None: ...
    def MCRY(self, angle: float, control_indices: int | Sequence[int], target_indices: int | Sequence[int]) -> None: ...
    def MCRZ(self, angle: float, control_indices: int | Sequence[int], target_indices: int | Sequence[int]) -> None: ...
    def MCPhase(self, angle: float, control_indices: int | Sequence[int], target_indices: int | Sequence[int]) -> None: ...
    def MCXPow(
            self,
            power: float,
            global_shift: float,
            control_indices: int | Sequence[int],
            target_indices: int | Sequence[int]
        ) -> None: ...
    def MCYPow(
            self,
            power: float,
            global_shift: float,
            control_indices: int | Sequence[int],
            target_indices: int | Sequence[int]
        ) -> None: ...
    def MCZPow(
            self,
            power: float,
            global_shift: float,
            control_indices: int | Sequence[int],
            target_indices: int | Sequence[int]
        ) -> None: ...
    def MCRXX(
            self,
            angle: float,
            control_indices: int | Sequence[int],
            first_target_index: int,
            second_target_index: int
        ) -> None: ...
    def MCRYY(
            self,
            angle: float,
            control_indices: int | Sequence[int],
            first_target_index: int,
            second_target_index: int
        ) -> None: ...
    def MCRZZ(
            self,
            angle: float,
            control_indices: int | Sequence[int],
            first_target_index: int,
            second_target_index: int
        ) -> None: ...
    @abstractmethod
    def MCU3(self, angles: Sequence[float], control_indices: int | Sequence[int], target_indices: int | Sequence[int]) -> None: ...
    @abstractmethod
    def MCSWAP(self, control_indices: int | Sequence[int], first_target_index: int, second_target_index: int) -> None: ...
    def UCPauliRot(
            self,
            angles: Sequence[float],
            rot_axis: Literal["X", "Y", "Z"],
            control_indices: int | Sequence[int],
            target_index: int
        ) -> None: ...
    def UCRX(self, angles: Sequence[float], control_indices: int | Sequence[int], target_index: int) -> None: ...
    def UCRY(self, angles: Sequence[float], control_indices: int | Sequence[int], target_index: int) -> None: ...
    def UCRZ(self, angles: Sequence[float], control_indices: int | Sequence[int], target_index: int) -> None: ...
    def _Diagonal(self, diagnoal: NDArray[np.complex128], qubit_indices: int | Sequence[int]) -> None: ...
    def Diagonal(self, diagnoal: NDArray[np.complex128], qubit_indices: int | Sequence[int]) -> None: ...
    def UC(
            self,
            gates: list[NDArray[np.complex128]],
            control_indices: int | Sequence[int],
            target_index: int,
            up_to_diagonal: bool=False,
            multiplexor_simplification: bool=True
        ) -> None: ...
    @abstractmethod
    def GlobalPhase(self, angle: float) -> None: ...
    def merge_global_phases(self) -> None: ...
    def QFT(
            self,
            qubit_indices: int | Sequence[int],
            do_swaps: bool=True,
            approximation_degree: int=0,
            inverse: bool=False
        ) -> None: ...
    def initialize(self, state: NDArray[np.complex128] | Bra | Ket, qubit_indices: int | Sequence[int]) -> None: ...
    def unitary(self, unitary_matrix: NDArray[np.complex128] | Operator, qubit_indices: int | Sequence[int]) -> None: ...
    def vertical_reverse(self) -> None: ...
    def horizontal_reverse(self, adjoint: bool=True) -> None: ...
    def add(self, circuit: Circuit, qubit_indices: int | Sequence[int]) -> None: ...
    @abstractmethod
    def measure(self, qubit_indices: int | Sequence[int]) -> None: ...
    def measure_all(self) -> None: ...
    @abstractmethod
    def get_statevector(self, backend: Backend | None = None) -> NDArray[np.complex128]: ...
    @abstractmethod
    def get_counts(self, num_shots: int, backend: Backend | None = None) -> dict[str, int]: ...
    def get_depth(self) -> int: ...
    def get_width(self) -> int: ...
    @abstractmethod
    def get_unitary(self) -> NDArray[np.complex128]: ...
    def get_instructions(self, include_measurements: bool=True) -> list[dict]: ...
    def get_dag(self) -> DAGCircuit: ...
    def get_global_phase(self) -> float: ...
    def count_ops(self) -> dict[str, int]: ...
    @abstractmethod
    def reset_qubit(self, qubit_indices: int | Sequence[int]) -> None: ...
    def remove_measurements(self) -> Circuit: ...
    def decompose(self, reps: int=1, full: bool=False) -> Circuit: ...
    def transpile(self, direct_transpile: bool=True, synthesis_method: UnitaryPreparation | None = None) -> None: ...
    def compress(self, compression_percentage: float) -> None: ...
    def change_mapping(self, qubit_indices: Sequence[int]) -> None: ...
    def convert(self, circuit_framework: Type[Circuit]) -> Circuit: ...
    def control(self, num_controls: int) -> Circuit: ...
    def update(self) -> None: ...
    @abstractmethod
    def to_qasm(self) -> str: ...
    def to_quimb(self) -> qtn.Circuit: ...
    @staticmethod
    def from_cirq(cirq_circuit: cirq.Circuit, output_framework: Type[Circuit]) -> Circuit: ...
    @staticmethod
    def from_pennylane(pennylane_circuit: qml.QNode, output_framework: Type[Circuit]) -> Circuit: ...
    @staticmethod
    def from_qiskit(qiskit_circuit: qiskit.QuantumCircuit, output_framework: Type[Circuit]) -> Circuit: ...
    @staticmethod
    def from_tket(tket_circuit: pytket.Circuit, output_framework: Type[Circuit]) -> Circuit: ...
    @staticmethod
    def from_qasm(qasm: str, output_framework: Type[Circuit]) -> Circuit: ...
    def copy(self) -> Circuit: ...
    def reset(self) -> None: ...
    @abstractmethod
    def draw(self): ...
    def plot_histogram(self, non_zeros_only: bool=False) -> plt.Figure: ...
    def __eq__(self, other_circuit: object) -> bool: ...
    def __len__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def generate_calls(self) -> str: ...
    @classmethod
    def __subclasscheck__(cls, C) -> bool: ...
    @classmethod
    def __subclasshook__(cls, C) -> bool | NotImplementedType: ...
    @classmethod
    def __instancecheck__(cls, C) -> bool: ...
